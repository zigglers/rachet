name: Tool Submission Pipeline

on:
  issues:
    types: [opened, edited]
  push:
    branches:
      - main
    paths:
      - 'tools/**'

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process-submission:
    name: Process Tool Submission
    runs-on: ubuntu-latest
    # Only run on issues with the tool-submission label
    if: contains(github.event.issue.labels.*.name, 'tool-submission')
    
    steps:
      # Phase 1: Setup
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      # Phase 2: Parse Issue and Generate Manifest
      - name: Parse Issue Body
        id: parse-issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            console.log('Parsing issue body:', body);
            
            // Parse fields from issue template
            const parseField = (fieldName) => {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\n([^#]*?)(?=\\n\\n###|$)`, 's');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };
            
            // Extract required fields
            const repoUrl = parseField('Repository URL');
            const description = parseField('Description');
            
            if (!repoUrl || !description) {
              core.setFailed('Missing required fields: Repository URL and Description');
              
              // Post comment about missing fields
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `## ‚ùå Missing Required Information\n\nPlease edit your issue to include:\n- **Repository URL**: The GitHub repository containing your tool\n- **Description**: A brief description of what your tool does\n\nUse the issue template as a guide.`
              });
              return;
            }
            
            // Extract optional fields
            const publisherField = parseField('Publisher');
            const publisher = (publisherField && publisherField !== '_No response_') ? publisherField : issue.user.login;
            
            const organizationField = parseField('Organization');
            const organization = (organizationField && organizationField !== '_No response_') ? organizationField : null;
            
            const toolNameField = parseField('Tool Name');
            const toolName = (toolNameField && toolNameField !== '_No response_') ? toolNameField : null;
            
            const commitHashField = parseField('Commit Hash');
            const commitHash = (commitHashField && commitHashField !== '_No response_') ? commitHashField : null;
            
            const versionField = parseField('Version');
            const version = (versionField && versionField !== '_No response_') ? versionField : null;
            
            // Extract repo info
            const repoRegex = /github\.com\/([^\/]+)\/([^\/\s]+)/;
            const repoInfo = repoUrl.match(repoRegex);
            
            if (!repoInfo) {
              core.setFailed('Invalid repository URL format');
              return;
            }
            
            const repoOrg = repoInfo[1];
            const repoName = repoInfo[2].replace(/\.git$/, '');
            
            // Set defaults
            const finalOrganization = organization || repoOrg;
            const finalToolName = toolName || repoName;
            
            // Output manifest data
            core.setOutput('repo_url', repoUrl);
            core.setOutput('repo_org', repoOrg);
            core.setOutput('repo_name', repoName);
            core.setOutput('description', description);
            core.setOutput('publisher', publisher);
            core.setOutput('organization', finalOrganization);
            core.setOutput('tool_name', finalToolName);
            core.setOutput('commit_hash', commitHash);
            core.setOutput('version', version);
            
            console.log('Parsed manifest:', {
              repoUrl,
              description,
              publisher,
              organization: finalOrganization,
              toolName: finalToolName,
              commitHash,
              version
            });
      
      # Phase 3: Clone and Validate Tool Repository
      - name: Clone Tool Repository
        if: success()
        id: clone-tool
        run: |
          echo "üì• Cloning tool repository..."
          
          REPO_URL="${{ steps.parse-issue.outputs.repo_url }}"
          COMMIT_HASH="${{ steps.parse-issue.outputs.commit_hash }}"
          
          # Clone the repository
          git clone "$REPO_URL" tool-repo
          cd tool-repo
          
          # Use specific commit or latest main
          if [[ -n "$COMMIT_HASH" && "$COMMIT_HASH" != "_No response_" ]]; then
            echo "Checking out commit: $COMMIT_HASH"
            git checkout "$COMMIT_HASH"
          else
            echo "Using latest main branch"
            COMMIT_HASH=$(git rev-parse --short HEAD)
          fi
          
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          
          # Generate version if not specified
          VERSION="${{ steps.parse-issue.outputs.version }}"
          if [[ -z "$VERSION" || "$VERSION" == "_No response_" ]]; then
            VERSION="$COMMIT_HASH"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      # Phase 4: Build and Bundle Tool
      - name: Setup Build Environment
        if: success()
        run: |
          # Create a temporary build directory
          mkdir -p build-temp
          cd build-temp
          
          # Install build dependencies
          npm init -y
          npm install esbuild @types/node typescript
          # Install clanker as dev dependency for validation
          npm install --save-dev @ziggler/clanker@latest
          
          # Copy build script to temp directory
          cd ..
          
          # Create build script
          cat > build-temp/build-tool.js << 'EOF'
          const esbuild = require('esbuild');
          const fs = require('fs');
          const path = require('path');
          
          async function build() {
            const toolDir = '../tool-repo';
            const outputDir = '../build-output';
            
            // Find entry point
            let entryPoint;
            const possibleEntries = [
              'src/index.ts',
              'src/index.tsx',
              'src/index.js',
              'src/index.jsx',
              'index.ts',
              'index.tsx',
              'index.js',
              'index.jsx'
            ];
            
            for (const entry of possibleEntries) {
              if (fs.existsSync(path.join(toolDir, entry))) {
                entryPoint = path.join(toolDir, entry);
                break;
              }
            }
            
            if (!entryPoint) {
              throw new Error('No entry point found');
            }
            
            console.log('Building from:', entryPoint);
            
            // Get external dependencies from package.json if it exists
            let externalDeps = [];
            const packageJsonPath = path.join(toolDir, 'package.json');
            if (fs.existsSync(packageJsonPath)) {
              const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
              const deps = packageJson.dependencies || {};
              const peerDeps = packageJson.peerDependencies || {};
              externalDeps = [...Object.keys(deps), ...Object.keys(peerDeps)];
              console.log('Found dependencies to mark as external:', externalDeps);
            }
            
            // Bundle the tool
            await esbuild.build({
              entryPoints: [entryPoint],
              bundle: true,
              format: 'esm',
              platform: 'node',
              target: 'node16',
              outfile: path.join(outputDir, 'index.js'),
              external: [
                // Core Node.js modules
                'child_process',
                'fs',
                'path',
                'os',
                'util',
                'stream',
                'events',
                'crypto',
                'http',
                'https',
                'url',
                'querystring',
                'buffer',
                'process',
                // Clanker and common UI dependencies
                '@ziggler/clanker',
                'react',
                'ink',
                // Tool-specific dependencies from package.json
                ...externalDeps
              ],
              // Avoid top-level await issues
              supported: {
                'top-level-await': false
              }
            });
            
            console.log('‚úÖ Build complete');
          }
          
          build().catch(err => {
            console.error('‚ùå Build failed:', err);
            process.exit(1);
          });
          EOF
      
      - name: Build Tool
        if: success()
        id: build
        run: |
          echo "üî® Building tool..."
          
          # Check if tool has dependencies and install them
          if [[ -f "tool-repo/package.json" ]]; then
            echo "üì¶ Installing tool dependencies..."
            cd tool-repo
            npm install --production
            cd ..
          fi
          
          # Create output directory
          mkdir -p build-output
          
          # Run build from temp directory
          cd build-temp && node build-tool.js && cd ..
          
          # Check if build succeeded
          if [[ ! -f "build-output/index.js" ]]; then
            echo "‚ùå Build failed: No output file"
            exit 1
          fi
          
          echo "‚úÖ Build successful"
          ls -la build-output/
          
          # Create package.json for the tool if it has dependencies
          if [[ -f "tool-repo/package.json" ]]; then
            echo "üì¶ Creating package.json for tool dependencies..."
            
            # Extract dependencies from the original package.json
            DEPS=$(cat tool-repo/package.json | jq -r '.dependencies // {}')
            PEER_DEPS=$(cat tool-repo/package.json | jq -r '.peerDependencies // {}')
            
            # Create a minimal package.json for the tool
            cat > build-output/package.json << EOF
          {
            "name": "${{ steps.parse-issue.outputs.tool_name }}",
            "version": "${{ steps.clone-tool.outputs.version }}",
            "description": "${{ steps.parse-issue.outputs.description }}",
            "main": "index.js",
            "dependencies": $DEPS,
            "peerDependencies": $PEER_DEPS
          }
          EOF
            
            echo "Created package.json with dependencies"
          fi
      
      # Phase 5: Validate Tool Format
      - name: Validate Tool Format
        if: success()
        id: validate
        run: |
          echo "üîç Validating tool format..."
          
          # Copy built file to build-temp for validation with dependencies
          cp build-output/index.js build-temp/
          
          # If tool has dependencies, copy node_modules to build-temp for validation
          if [[ -d "tool-repo/node_modules" ]]; then
            echo "üì¶ Copying dependencies for validation..."
            cp -r tool-repo/node_modules build-temp/
          fi
          
          # Create validation script in build-temp
          cat > build-temp/validate-tool.mjs << 'EOF'
          import fs from 'fs';
          
          async function validate() {
            try {
              // Load the built tool using dynamic import
              const tool = await import('./index.js');
              
              // Check if it exports something
              const toolDef = tool.default || tool;
              
              if (!toolDef || typeof toolDef !== 'object') {
                throw new Error('Tool must export an object (default export or module.exports)');
              }
              
              // Check required properties
              const required = ['id', 'name', 'description', 'execute'];
              const missing = required.filter(prop => !toolDef[prop]);
              
              if (missing.length > 0) {
                throw new Error(`Missing required properties: ${missing.join(', ')}`);
              }
              
              // Check property types
              if (typeof toolDef.id !== 'string') {
                throw new Error('id must be a string');
              }
              
              if (typeof toolDef.name !== 'string') {
                throw new Error('name must be a string');
              }
              
              if (typeof toolDef.description !== 'string') {
                throw new Error('description must be a string');
              }
              
              if (typeof toolDef.execute !== 'function') {
                throw new Error('execute must be a function');
              }
              
              console.log('‚úÖ Tool format is valid');
              console.log('Tool ID:', toolDef.id);
              console.log('Tool Name:', toolDef.name);
              console.log('Tool Description:', toolDef.description);
              
            } catch (error) {
              console.error('‚ùå Validation failed:', error.message);
              process.exit(1);
            }
          }
          
          validate();
          EOF
          
          # Run validation from build-temp directory where dependencies are installed
          cd build-temp && node validate-tool.mjs
      
      # Phase 6: Create Manifest
      - name: Create Tool Manifest
        if: success()
        id: manifest
        run: |
          echo "üìã Creating manifest..."
          
          cat > build-output/manifest.yml << EOF
          id: ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}
          name: ${{ steps.parse-issue.outputs.tool_name }}
          description: ${{ steps.parse-issue.outputs.description }}
          version: ${{ steps.clone-tool.outputs.version }}
          publisher: ${{ steps.parse-issue.outputs.publisher }}
          organization: ${{ steps.parse-issue.outputs.organization }}
          repository: ${{ steps.parse-issue.outputs.repo_url }}
          commit: ${{ steps.clone-tool.outputs.commit_hash }}
          date: $(date -u +%Y-%m-%d)
          EOF
          
          echo "Manifest created:"
          cat build-output/manifest.yml
      
      # Phase 7: Security Scan
      - name: Security Scan
        if: success()
        id: security
        continue-on-error: true
        run: |
          echo "üîí Running security scan..."
          
          cd tool-repo
          
          # Check for package.json
          if [[ -f "package.json" ]]; then
            # Install dependencies for audit
            npm install --package-lock-only || true
            
            # Run audit
            npm audit --json > ../audit-report.json || true
            
            # Check for high/critical vulnerabilities
            if jq -e '.metadata.vulnerabilities.high > 0 or .metadata.vulnerabilities.critical > 0' ../audit-report.json > /dev/null 2>&1; then
              echo "‚ö†Ô∏è  Security vulnerabilities found"
              echo "security_status=warning" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ No high/critical vulnerabilities"
              echo "security_status=pass" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ No package.json to audit"
            echo "security_status=pass" >> $GITHUB_OUTPUT
          fi
      
      # Phase 8: Create Integration Branch
      - name: Create Integration Branch
        if: success()
        id: integration
        run: |
          echo "üåø Creating integration branch..."
          
          # Configure git
          git config user.name "Clanker Bot"
          git config user.email "bot@clanker.dev"
          
          # Create branch name
          BRANCH="${{ steps.parse-issue.outputs.publisher }}/${{ steps.parse-issue.outputs.tool_name }}@${{ steps.clone-tool.outputs.commit_hash }}"
          
          # Create and checkout branch
          git checkout -b "$BRANCH"
          
          # Create tool directory
          TOOL_DIR="tools/${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}/${{ steps.clone-tool.outputs.version }}"
          mkdir -p "$TOOL_DIR"
          
          # Copy build artifacts
          cp build-output/* "$TOOL_DIR/"
          
          # Create or update tool metadata
          METADATA_FILE="tools/${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}/metadata.json"
          
          if [[ -f "$METADATA_FILE" ]]; then
            # Update existing metadata
            jq --arg version "${{ steps.clone-tool.outputs.version }}" \
               --arg date "$(date -u +%Y-%m-%d)" \
               --arg commit "${{ steps.clone-tool.outputs.commit_hash }}" \
               '.versions[$version] = {"date": $date, "commit": $commit} | .latest = $version' \
               "$METADATA_FILE" > tmp.json && mv tmp.json "$METADATA_FILE"
          else
            # Create new metadata
            mkdir -p "$(dirname "$METADATA_FILE")"
            cat > "$METADATA_FILE" << EOF
          {
            "id": "${{ steps.parse-issue.outputs.tool_name }}",
            "name": "${{ steps.parse-issue.outputs.tool_name }}",
            "description": "${{ steps.parse-issue.outputs.description }}",
            "publisher": "${{ steps.parse-issue.outputs.publisher }}",
            "repository": "${{ steps.parse-issue.outputs.repo_url }}",
            "versions": {
              "${{ steps.clone-tool.outputs.version }}": {
                "date": "$(date -u +%Y-%m-%d)",
                "commit": "${{ steps.clone-tool.outputs.commit_hash }}"
              }
            },
            "latest": "${{ steps.clone-tool.outputs.version }}"
          }
          EOF
          fi
          
          # Clean up temporary files before committing (but keep tool artifacts)
          rm -rf build-temp build-output node_modules tool-repo audit-report.json pr-body.md 2>/dev/null || true
          # Clean up root package files but not in tools directory
          rm -f package.json package-lock.json 2>/dev/null || true
          
          # Commit and push only the tools directory
          git add tools/
          git commit -m "feat: add tool ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}@${{ steps.clone-tool.outputs.version }}"
          git push origin "$BRANCH"
          
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
      
      # Phase 9: Trigger PR Creation Workflow
      - name: Trigger PR Creation
        if: success()
        id: create-pr
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_TOKEN }}
          script: |
            try {
              // Trigger the PR creation workflow
              const result = await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'create-tool-pr.yml',
                ref: 'main',
                inputs: {
                  branch: '${{ steps.integration.outputs.branch }}',
                  tool_name: '${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}',
                  version: '${{ steps.clone-tool.outputs.version }}',
                  publisher: '${{ steps.parse-issue.outputs.publisher }}',
                  repository: '${{ steps.parse-issue.outputs.repo_url }}',
                  issue_number: '${{ github.event.issue.number }}',
                  security_status: '${{ steps.security.outputs.security_status }}'
                }
              });
              
              console.log('‚úÖ PR creation workflow triggered successfully');
              core.setOutput('workflow_triggered', 'true');
            } catch (error) {
              console.log('‚ö†Ô∏è Could not trigger PR workflow:', error.message);
              core.setOutput('workflow_triggered', 'false');
            }
      
      # Phase 10: Post Results
      - name: Post Results Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const success = ${{ steps.integration.outcome == 'success' }};
            const securityStatus = '${{ steps.security.outputs.security_status }}' || 'unknown';
            
            let comment = success ? 
              `## ‚úÖ Tool Submission Successful!\n\n` : 
              `## ‚ùå Tool Submission Failed\n\n`;
            
            // Add tool info
            comment += `### üì¶ Tool Information\n`;
            comment += `- **Name**: \`${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}\`\n`;
            comment += `- **Version**: \`${{ steps.clone-tool.outputs.version }}\`\n`;
            comment += `- **Publisher**: @${{ steps.parse-issue.outputs.publisher }}\n`;
            comment += `- **Repository**: ${{ steps.parse-issue.outputs.repo_url }}\n\n`;
            
            // Add status for each phase
            comment += `### üìä Pipeline Status\n`;
            comment += `- Manifest Parsing: ${'${{ steps.parse-issue.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Repository Clone: ${'${{ steps.clone-tool.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Build: ${'${{ steps.build.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Format Validation: ${'${{ steps.validate.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Security Scan: ${securityStatus === 'pass' ? '‚úÖ' : '‚ö†Ô∏è'}\n`;
            comment += `- Integration Branch: ${'${{ steps.integration.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Pull Request: ${'${{ steps.create-pr.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n\n`;
            
            if (success) {
              // Success message
              comment += `### üéâ Next Steps\n\n`;
              comment += `Your tool has been successfully built and integrated! `;
              
              const workflowTriggered = '${{ steps.create-pr.outputs.workflow_triggered }}' === 'true';
              if (workflowTriggered) {
                comment += `A pull request workflow has been triggered.\n\n`;
                comment += `> ‚ÑπÔ∏è **Note**: The PR will be created in a separate workflow. Check back in a moment for the PR link.\n\n`;
              } else {
                comment += `The integration branch has been created.\n\n`;
                comment += `> ‚ö†Ô∏è **Note**: The PR workflow could not be triggered automatically. A maintainer will create the PR manually.\n\n`;
              }
              
              comment += `**Branch**: \`${{ steps.integration.outputs.branch }}\`\n\n`;
              
              comment += `A maintainer will review your submission and merge it to the main registry. `;
              comment += `Once merged, your tool will be available for installation:\n\n`;
              
              comment += `\`\`\`bash\n`;
              comment += `clanker install ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}\n`;
              comment += `\`\`\`\n\n`;
              
              if (securityStatus === 'warning') {
                comment += `### ‚ö†Ô∏è Security Notice\n`;
                comment += `Some security vulnerabilities were detected. While not blocking, please consider addressing them.\n\n`;
              }
              
              comment += `Thank you @${{ steps.parse-issue.outputs.publisher }} for your contribution! üôè\n\n`;
              
              // Close the issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed'
              });
              
            } else {
              // Failure message
              comment += `### ‚ùå Action Required\n\n`;
              
              // Specific error guidance
              if (${{ steps.parse-issue.outcome != 'success' }}) {
                comment += `Please edit your issue to include the required fields.\n`;
              } else if (${{ steps.clone-tool.outcome != 'success' }}) {
                comment += `Failed to clone the repository. Please check:\n`;
                comment += `- Repository URL is correct and accessible\n`;
                comment += `- Commit hash (if specified) exists\n`;
              } else if (${{ steps.build.outcome != 'success' }}) {
                comment += `Failed to build the tool. Please ensure:\n`;
                comment += `- Your tool has a valid entry point (index.ts/js)\n`;
                comment += `- All dependencies are properly declared\n`;
                comment += `- The code compiles without errors\n`;
              } else if (${{ steps.validate.outcome != 'success' }}) {
                comment += `Tool format validation failed. Please ensure your tool:\n`;
                comment += `- Exports an object with required properties (id, name, description, execute)\n`;
                comment += `- The execute property is a function\n`;
                comment += `- Follows the clanker tool format\n`;
              }
              
              comment += `\nPlease fix the issues and edit your issue to trigger the pipeline again.`;
            }
            
            // Post comment
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
  
  # Job to update registry when tools are added
  update-registry:
    name: Update Registry Index
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Generate Registry
        run: |
          echo "üìã Generating registry index..."
          node scripts/generate-registry.js
      
      - name: Commit Registry Updates
        run: |
          git config user.name "Clanker Bot"
          git config user.email "bot@clanker.gg"
          
          # Check if registry.json changed
          if git diff --quiet registry.json; then
            echo "No changes to registry"
          else
            git add registry.json
            git commit -m "chore: update registry index [skip ci]"
            git push
          fi
