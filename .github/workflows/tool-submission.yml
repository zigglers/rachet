name: Tool Submission Pipeline

on:
  issues:
    types: [opened, edited]

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  process-submission:
    name: Process Tool Submission
    runs-on: ubuntu-latest
    # Only run on issues with the tool-submission label
    if: contains(github.event.issue.labels.*.name, 'tool-submission')
    
    steps:
      # Phase 1: Setup
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      # Phase 2: Parse Issue and Generate Manifest
      - name: Parse Issue Body
        id: parse-issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            
            console.log('Parsing issue body:', body);
            
            // Parse fields from issue template
            const parseField = (fieldName) => {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\n([^#]*?)(?=\\n\\n###|$)`, 's');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };
            
            // Extract required fields
            const repoUrl = parseField('Repository URL');
            const description = parseField('Description');
            
            if (!repoUrl || !description) {
              core.setFailed('Missing required fields: Repository URL and Description');
              
              // Post comment about missing fields
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `## ‚ùå Missing Required Information\n\nPlease edit your issue to include:\n- **Repository URL**: The GitHub repository containing your tool\n- **Description**: A brief description of what your tool does\n\nUse the issue template as a guide.`
              });
              return;
            }
            
            // Extract optional fields
            const publisherField = parseField('Publisher');
            const publisher = (publisherField && publisherField !== '_No response_') ? publisherField : issue.user.login;
            
            const organizationField = parseField('Organization');
            const organization = (organizationField && organizationField !== '_No response_') ? organizationField : null;
            
            const toolNameField = parseField('Tool Name');
            const toolName = (toolNameField && toolNameField !== '_No response_') ? toolNameField : null;
            
            const commitHashField = parseField('Commit Hash');
            const commitHash = (commitHashField && commitHashField !== '_No response_') ? commitHashField : null;
            
            const versionField = parseField('Version');
            const version = (versionField && versionField !== '_No response_') ? versionField : null;
            
            // Extract repo info
            const repoRegex = /github\.com\/([^\/]+)\/([^\/\s]+)/;
            const repoInfo = repoUrl.match(repoRegex);
            
            if (!repoInfo) {
              core.setFailed('Invalid repository URL format');
              return;
            }
            
            const repoOrg = repoInfo[1];
            const repoName = repoInfo[2].replace(/\.git$/, '');
            
            // Set defaults
            const finalOrganization = organization || repoOrg;
            const finalToolName = toolName || repoName;
            
            // Output manifest data
            core.setOutput('repo_url', repoUrl);
            core.setOutput('repo_org', repoOrg);
            core.setOutput('repo_name', repoName);
            core.setOutput('description', description);
            core.setOutput('publisher', publisher);
            core.setOutput('organization', finalOrganization);
            core.setOutput('tool_name', finalToolName);
            core.setOutput('commit_hash', commitHash);
            core.setOutput('version', version);
            
            console.log('Parsed manifest:', {
              repoUrl,
              description,
              publisher,
              organization: finalOrganization,
              toolName: finalToolName,
              commitHash,
              version
            });
      
      # Phase 3: Clone and Validate Tool Repository
      - name: Clone Tool Repository
        if: success()
        id: clone-tool
        run: |
          echo "üì• Cloning tool repository..."
          
          REPO_URL="${{ steps.parse-issue.outputs.repo_url }}"
          COMMIT_HASH="${{ steps.parse-issue.outputs.commit_hash }}"
          
          # Clone the repository
          git clone "$REPO_URL" tool-repo
          cd tool-repo
          
          # Use specific commit or latest main
          if [[ -n "$COMMIT_HASH" && "$COMMIT_HASH" != "_No response_" ]]; then
            echo "Checking out commit: $COMMIT_HASH"
            git checkout "$COMMIT_HASH"
          else
            echo "Using latest main branch"
            COMMIT_HASH=$(git rev-parse --short HEAD)
          fi
          
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          
          # Generate version if not specified
          VERSION="${{ steps.parse-issue.outputs.version }}"
          if [[ -z "$VERSION" || "$VERSION" == "_No response_" ]]; then
            VERSION="$COMMIT_HASH"
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
      
      # Phase 4: Build and Bundle Tool
      - name: Setup Build Environment
        if: success()
        run: |
          # Create a temporary build directory
          mkdir -p build-temp
          cd build-temp
          
          # Install build dependencies
          npm init -y
          npm install esbuild @types/node typescript
          # Install clanker as dev dependency for validation
          npm install --save-dev @ziggler/clanker@latest
          
          # Copy build script to temp directory
          cd ..
          
          # Create build script
          cat > build-temp/build-tool.js << 'EOF'
          const esbuild = require('esbuild');
          const fs = require('fs');
          const path = require('path');
          
          async function build() {
            const toolDir = '../tool-repo';
            const outputDir = '../build-output';
            
            // Find entry point
            let entryPoint;
            const possibleEntries = [
              'src/index.ts',
              'src/index.tsx',
              'src/index.js',
              'src/index.jsx',
              'index.ts',
              'index.tsx',
              'index.js',
              'index.jsx'
            ];
            
            for (const entry of possibleEntries) {
              if (fs.existsSync(path.join(toolDir, entry))) {
                entryPoint = path.join(toolDir, entry);
                break;
              }
            }
            
            if (!entryPoint) {
              throw new Error('No entry point found');
            }
            
            console.log('Building from:', entryPoint);
            
            // Bundle the tool
            await esbuild.build({
              entryPoints: [entryPoint],
              bundle: true,
              format: 'esm',
              platform: 'node',
              target: 'node16',
              outfile: path.join(outputDir, 'index.js'),
              external: [
                'react',
                'ink',
                '@ziggler/clanker',
                'child_process',
                'fs',
                'path',
                'os',
                'util',
                'stream',
                'events',
                'crypto'
              ],
              // Avoid top-level await issues
              supported: {
                'top-level-await': false
              }
            });
            
            console.log('‚úÖ Build complete');
          }
          
          build().catch(err => {
            console.error('‚ùå Build failed:', err);
            process.exit(1);
          });
          EOF
      
      - name: Build Tool
        if: success()
        id: build
        run: |
          echo "üî® Building tool..."
          
          # Create output directory
          mkdir -p build-output
          
          # Run build from temp directory
          cd build-temp && node build-tool.js && cd ..
          
          # Check if build succeeded
          if [[ ! -f "build-output/index.js" ]]; then
            echo "‚ùå Build failed: No output file"
            exit 1
          fi
          
          echo "‚úÖ Build successful"
          ls -la build-output/
      
      # Phase 5: Validate Tool Format
      - name: Validate Tool Format
        if: success()
        id: validate
        run: |
          echo "üîç Validating tool format..."
          
          # Copy built file to build-temp for validation with dependencies
          cp build-output/index.js build-temp/
          
          # Create validation script in build-temp
          cat > build-temp/validate-tool.mjs << 'EOF'
          import fs from 'fs';
          
          async function validate() {
            try {
              // Load the built tool using dynamic import
              const tool = await import('./index.js');
              
              // Check if it exports something
              const toolDef = tool.default || tool;
              
              if (!toolDef || typeof toolDef !== 'object') {
                throw new Error('Tool must export an object (default export or module.exports)');
              }
              
              // Check required properties
              const required = ['id', 'name', 'description', 'execute'];
              const missing = required.filter(prop => !toolDef[prop]);
              
              if (missing.length > 0) {
                throw new Error(`Missing required properties: ${missing.join(', ')}`);
              }
              
              // Check property types
              if (typeof toolDef.id !== 'string') {
                throw new Error('id must be a string');
              }
              
              if (typeof toolDef.name !== 'string') {
                throw new Error('name must be a string');
              }
              
              if (typeof toolDef.description !== 'string') {
                throw new Error('description must be a string');
              }
              
              if (typeof toolDef.execute !== 'function') {
                throw new Error('execute must be a function');
              }
              
              console.log('‚úÖ Tool format is valid');
              console.log('Tool ID:', toolDef.id);
              console.log('Tool Name:', toolDef.name);
              console.log('Tool Description:', toolDef.description);
              
            } catch (error) {
              console.error('‚ùå Validation failed:', error.message);
              process.exit(1);
            }
          }
          
          validate();
          EOF
          
          # Run validation from build-temp directory where dependencies are installed
          cd build-temp && node validate-tool.mjs
      
      # Phase 6: Create Manifest
      - name: Create Tool Manifest
        if: success()
        id: manifest
        run: |
          echo "üìã Creating manifest..."
          
          cat > build-output/manifest.yml << EOF
          id: ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}
          name: ${{ steps.parse-issue.outputs.tool_name }}
          description: ${{ steps.parse-issue.outputs.description }}
          version: ${{ steps.clone-tool.outputs.version }}
          publisher: ${{ steps.parse-issue.outputs.publisher }}
          organization: ${{ steps.parse-issue.outputs.organization }}
          repository: ${{ steps.parse-issue.outputs.repo_url }}
          commit: ${{ steps.clone-tool.outputs.commit_hash }}
          date: $(date -u +%Y-%m-%d)
          EOF
          
          echo "Manifest created:"
          cat build-output/manifest.yml
      
      # Phase 7: Security Scan
      - name: Security Scan
        if: success()
        id: security
        continue-on-error: true
        run: |
          echo "üîí Running security scan..."
          
          cd tool-repo
          
          # Check for package.json
          if [[ -f "package.json" ]]; then
            # Install dependencies for audit
            npm install --package-lock-only || true
            
            # Run audit
            npm audit --json > ../audit-report.json || true
            
            # Check for high/critical vulnerabilities
            if jq -e '.metadata.vulnerabilities.high > 0 or .metadata.vulnerabilities.critical > 0' ../audit-report.json > /dev/null 2>&1; then
              echo "‚ö†Ô∏è  Security vulnerabilities found"
              echo "security_status=warning" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ No high/critical vulnerabilities"
              echo "security_status=pass" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ No package.json to audit"
            echo "security_status=pass" >> $GITHUB_OUTPUT
          fi
      
      # Phase 8: Create Integration Branch
      - name: Create Integration Branch
        if: success()
        id: integration
        run: |
          echo "üåø Creating integration branch..."
          
          # Configure git
          git config user.name "Clanker Bot"
          git config user.email "bot@clanker.dev"
          
          # Create branch name
          BRANCH="${{ steps.parse-issue.outputs.publisher }}/${{ steps.parse-issue.outputs.tool_name }}@${{ steps.clone-tool.outputs.commit_hash }}"
          
          # Create and checkout branch
          git checkout -b "$BRANCH"
          
          # Create tool directory
          TOOL_DIR="tools/${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}/${{ steps.clone-tool.outputs.version }}"
          mkdir -p "$TOOL_DIR"
          
          # Copy build artifacts
          cp build-output/* "$TOOL_DIR/"
          
          # Create or update tool metadata
          METADATA_FILE="tools/${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}/metadata.json"
          
          if [[ -f "$METADATA_FILE" ]]; then
            # Update existing metadata
            jq --arg version "${{ steps.clone-tool.outputs.version }}" \
               --arg date "$(date -u +%Y-%m-%d)" \
               --arg commit "${{ steps.clone-tool.outputs.commit_hash }}" \
               '.versions[$version] = {"date": $date, "commit": $commit} | .latest = $version' \
               "$METADATA_FILE" > tmp.json && mv tmp.json "$METADATA_FILE"
          else
            # Create new metadata
            mkdir -p "$(dirname "$METADATA_FILE")"
            cat > "$METADATA_FILE" << EOF
          {
            "id": "${{ steps.parse-issue.outputs.tool_name }}",
            "name": "${{ steps.parse-issue.outputs.tool_name }}",
            "description": "${{ steps.parse-issue.outputs.description }}",
            "publisher": "${{ steps.parse-issue.outputs.publisher }}",
            "repository": "${{ steps.parse-issue.outputs.repo_url }}",
            "versions": {
              "${{ steps.clone-tool.outputs.version }}": {
                "date": "$(date -u +%Y-%m-%d)",
                "commit": "${{ steps.clone-tool.outputs.commit_hash }}"
              }
            },
            "latest": "${{ steps.clone-tool.outputs.version }}"
          }
          EOF
          fi
          
          # Clean up temporary files before committing
          rm -rf build-temp build-output node_modules package*.json tool-repo audit-report.json pr-body.md 2>/dev/null || true
          
          # Commit and push only the tools directory
          git add tools/
          git commit -m "feat: add tool ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}@${{ steps.clone-tool.outputs.version }}"
          git push origin "$BRANCH"
          
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
      
      # Phase 9: Create Pull Request  
      - name: Create Pull Request
        if: success()
        id: create-pr
        run: |
          echo "üîÑ Creating pull request..."
          
          # Determine security status icon
          if [[ "${{ steps.security.outputs.security_status }}" == "pass" ]]; then
            SECURITY_ICON="‚úÖ"
          else
            SECURITY_ICON="‚ö†Ô∏è"
          fi
          
          # Create PR body using heredoc
          cat > pr-body.md << EOF
          ## Automated Tool Integration
          
          This PR was automatically generated from issue #${{ github.event.issue.number }}.
          
          ### Tool Information
          - **Name**: ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}
          - **Version**: ${{ steps.clone-tool.outputs.version }}
          - **Publisher**: @${{ steps.parse-issue.outputs.publisher }}
          - **Repository**: ${{ steps.parse-issue.outputs.repo_url }}
          
          ### Pipeline Status
          - ‚úÖ Manifest parsed successfully
          - ‚úÖ Repository cloned
          - ‚úÖ Tool built successfully
          - ‚úÖ Format validated
          - ${SECURITY_ICON} Security scan
          
          Closes #${{ github.event.issue.number }}
          EOF
          
          # Create PR using GitHub CLI
          PR_URL=$(gh pr create \
            --base main \
            --head "${{ steps.integration.outputs.branch }}" \
            --title "ü§ñ Add tool: ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}@${{ steps.clone-tool.outputs.version }}" \
            --body-file pr-body.md \
            --label "tool-submission" \
            --label "automated")
          
          # Extract PR number from URL
          PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
          echo "pull-request-number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "pull-request-url=$PR_URL" >> $GITHUB_OUTPUT
          
          # Clean up
          rm -f pr-body.md
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      # Phase 10: Post Results
      - name: Post Results Comment
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const success = ${{ steps.integration.outcome == 'success' }};
            const securityStatus = '${{ steps.security.outputs.security_status }}' || 'unknown';
            
            let comment = success ? 
              `## ‚úÖ Tool Submission Successful!\n\n` : 
              `## ‚ùå Tool Submission Failed\n\n`;
            
            // Add tool info
            comment += `### üì¶ Tool Information\n`;
            comment += `- **Name**: \`${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}\`\n`;
            comment += `- **Version**: \`${{ steps.clone-tool.outputs.version }}\`\n`;
            comment += `- **Publisher**: @${{ steps.parse-issue.outputs.publisher }}\n`;
            comment += `- **Repository**: ${{ steps.parse-issue.outputs.repo_url }}\n\n`;
            
            // Add status for each phase
            comment += `### üìä Pipeline Status\n`;
            comment += `- Manifest Parsing: ${'${{ steps.parse-issue.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Repository Clone: ${'${{ steps.clone-tool.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Build: ${'${{ steps.build.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Format Validation: ${'${{ steps.validate.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Security Scan: ${securityStatus === 'pass' ? '‚úÖ' : '‚ö†Ô∏è'}\n`;
            comment += `- Integration Branch: ${'${{ steps.integration.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n`;
            comment += `- Pull Request: ${'${{ steps.create-pr.outcome }}' === 'success' ? '‚úÖ' : '‚ùå'}\n\n`;
            
            if (success) {
              // Success message
              comment += `### üéâ Next Steps\n\n`;
              comment += `Your tool has been successfully built and integrated! `;
              comment += `A pull request has been created for review.\n\n`;
              
              comment += `**Pull Request**: #${{ steps.create-pr.outputs.pull-request-number }}\n`;
              comment += `**Branch**: \`${{ steps.integration.outputs.branch }}\`\n\n`;
              
              comment += `A maintainer will review your submission and merge it to the main registry. `;
              comment += `Once merged, your tool will be available for installation:\n\n`;
              
              comment += `\`\`\`bash\n`;
              comment += `clanker install ${{ steps.parse-issue.outputs.organization }}/${{ steps.parse-issue.outputs.tool_name }}\n`;
              comment += `\`\`\`\n\n`;
              
              if (securityStatus === 'warning') {
                comment += `### ‚ö†Ô∏è Security Notice\n`;
                comment += `Some security vulnerabilities were detected. While not blocking, please consider addressing them.\n\n`;
              }
              
              comment += `Thank you @${{ steps.parse-issue.outputs.publisher }} for your contribution! üôè\n\n`;
              
              // Close the issue
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                state: 'closed'
              });
              
            } else {
              // Failure message
              comment += `### ‚ùå Action Required\n\n`;
              
              // Specific error guidance
              if (${{ steps.parse-issue.outcome != 'success' }}) {
                comment += `Please edit your issue to include the required fields.\n`;
              } else if (${{ steps.clone-tool.outcome != 'success' }}) {
                comment += `Failed to clone the repository. Please check:\n`;
                comment += `- Repository URL is correct and accessible\n`;
                comment += `- Commit hash (if specified) exists\n`;
              } else if (${{ steps.build.outcome != 'success' }}) {
                comment += `Failed to build the tool. Please ensure:\n`;
                comment += `- Your tool has a valid entry point (index.ts/js)\n`;
                comment += `- All dependencies are properly declared\n`;
                comment += `- The code compiles without errors\n`;
              } else if (${{ steps.validate.outcome != 'success' }}) {
                comment += `Tool format validation failed. Please ensure your tool:\n`;
                comment += `- Exports an object with required properties (id, name, description, execute)\n`;
                comment += `- The execute property is a function\n`;
                comment += `- Follows the clanker tool format\n`;
              }
              
              comment += `\nPlease fix the issues and edit your issue to trigger the pipeline again.`;
            }
            
            // Post comment
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
